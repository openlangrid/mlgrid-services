<!DOCTYPE html>
<html>
<head>
<meta charset="utf8">
</head>
<body>
<button id="startstop">●</button>
<select id="sampleRate">
    <option value="44100">44100</option>
    <option value="16000">16000</option>
    <option value="11025">11025</option>
</select>
<div id="results">
</div>
<script src="recorder.js"></script>
<script src="wavwriter.js"></script>
<script>
window.addEventListener("load", ()=>{
    const startStopBtn = document.getElementById("startstop");
    const sampleRateSelect = document.getElementById("sampleRate");
    const results = document.getElementById("results");

    const recorder = new Recorder();
    let recording = false;
    let wavWriter = null;
    let sampleRate = null;
    let targetSampleRate = null;
    recorder.onStartRecording = (stream, audioContext)=>{
        sampleRate = audioContext.sampleRate;
        wavWriter = new WavWriter(1, 16, sampleRate);
    };
    recorder.onProcessRecording = channelData =>{
        const uint8buff = downsampleBuffer(channelData,
            recorder.getAudioContext().sampleRate,
            targetSampleRate);
        wavWriter.addData(uint8buff);
    };
    recorder.onStopRecording = ()=>{
        const url = URL.createObjectURL(new Blob(
            [wavWriter.getWavFile()], {type: "audio/wav"}));
        const audio = document.createElement("audio");
        audio.controls = true;
        audio.src = url;
        results.appendChild(audio);
        const a = document.createElement("a");
        a.download = 'recordings.wav';
        a.href = url;
        a.textContent = "download";
        results.appendChild(a);
        results.appendChild(document.createElement("br"));
    };
    startStopBtn.addEventListener("click", e=>{
        e.preventDefault();
        if(recording){
            startStopBtn.textContent = "●";
            recorder.stop();
            recording = false;
        } else{
            startStopBtn.textContent = "■";
            targetSampleRate = sampleRateSelect.value;
            recorder.start(targetSampleRate);
            recording = true;
        }
    });
});

/**
 * @param {Float32Array} buffer
 * @param {number} sampleRate
 * @param {number} outSampleRate
 * @return {ArrayBuffer}
 */
function downsampleBuffer(buffer, sampleRate, outSampleRate){
	if (outSampleRate > sampleRate) {
		console.error('down-sampling rate should be smaller than the original one');
        return null;
	}
	const scale = sampleRate / outSampleRate;
	const newLength = Math.round(buffer.length / scale);
    const buff = new ArrayBuffer(newLength * 2);
    const view = new DataView(buff);
	let offsetResult = 0;
	let offsetBuffer = 0;
	while (offsetResult < newLength) {
		const nextOffsetBuffer = Math.round((offsetResult + 1) * scale);
		let accum = 0;
		let count = 0;
		for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i ++) {
			accum += buffer[i];
			count += 1;
		}
		let v = accum / count;
		v = v < 0 ? v * 0x8000 : v * 0x7fff;
        view.setUint16(offsetResult * 2, v, true);
		offsetResult++;
		offsetBuffer = nextOffsetBuffer;
	}
	return buff;
}
</script>
</body>
</html>